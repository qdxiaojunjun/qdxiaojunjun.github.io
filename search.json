[{"title":"C++11内容总结","url":"/2025/07/31/C++11%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/","content":"C++11内容总结一、关键字和语法auto： 可以根据右值，推导出右值的类型，然后左边变量的类型也就已知了！nullptr: 给指针专用（能够和整数进行区别） #define NULL 0forrach:  可以遍历数组，容器等等。。。for(Type val : container) &#x3D;》 底层就是通过指针或者迭代器来实现的{\tcout &lt;&lt; val &lt;&lt; “ “;}右值引用：move 移动语义函数和forward类型完美转发函数模板的一个新特性：typename… A 表示可变参（类型参数）\n二、绑定器和函数对象function: 函数对象bind：绑定器   bind1st 和 bind2nd + 二元函数对象 —》一元函数lambda表达式：\n三、智能指针share_ptr 和 weak_ptr \n四、容器set 和 map : 红黑树 O(lng n)unordered_set 和 unordered_map : 哈希表 O(1)array；数组   vectorforward_list: 前向链表 list\n五、 C++语言级别支持的多线程编程createThreadpthread_createclone\n","tags":["C++"]},{"title":"P3742 umi的函数","url":"/2025/07/15/P3742%20umi%E7%9A%84%E5%87%BD%E6%95%B0/","content":"P3742 umi的函数题目背景umi 找到了一个神秘的函数 f。\n题目描述这个函数接受两个字符串 s1,s2。这些字符串只能由小写字母组成，并且具有相同的长度。这个函数的输出是另一个长度与 s1,s2 相同的字符串 g。g的第 i个字符等于 s1的第 i 个字符和 s2 的第 i 个字符的最小值，简单来说，$$g_i&#x3D;min(s1_i,s2_i)$$。\n例如：$$f(\\verb!ab!,\\verb!ba!)&#x3D; \\verb!aa!，f(\\verb!nzwzl!,\\verb!zizez!)&#x3D;\\verb!niwel!。$$她现在有两个相同长度的只有小写字母的字符串 $x,y$。找出任何一个满足 $f(x,z)&#x3D;y$ 的字符串 $z$。如果找不到这样的字符串的话，请输出 $-1$。\n输入格式第一行给出以下两个字符串的长度 n\n第二行给出一个字符串 x。\n第三行给出一个字符串 y。\n输出格式第一行输出一个字符串，代表你找到的符合条件的字符串。找不到的话，请输出 -1。\n输入输出样例 #1输入 #12abaa\n\n输出 #1ba\n\n输入输出样例 #2输入 #25nzwzlniwel\n\n输出 #2xiyez\n\n输入输出样例 #3输入 #32abba\n\n输出 #3-1\n\n说明&#x2F;提示$$对于 100% 的数据，1\\le n\\le 100。$$\n思路​\t很简单的模拟，我们就先比较x字符串和y字符串，如果x字符串小于y字符串的话，直接返回-1就行了，其他的照着y字符串输出就行了。\nAC代码#include&lt;iostream&gt;using namespace std;void slove()&#123;\tint n;\tcin &gt;&gt; n;\tchar s1[n];\tchar s2[n];\tchar s3[n];\tfor(int i = 0; i &lt; n; i++)\t&#123;\t\tcin &gt;&gt;s1[i];\t&#125;\tfor(int i = 0; i &lt; n; i++)\t&#123;\t\tcin &gt;&gt;s2[i];\t&#125;\tfor(int i = 0; i &lt; n; i++)\t&#123;\t\tif(s1[i] &lt; s2[i])\t\t&#123;\t\t\tcout &lt;&lt; -1 &lt;&lt;endl;\t\t\treturn;\t\t&#125;\t\telse\t\t&#123;\t\t\ts3[i] = s2[i];\t\t&#125;\t&#125;\tfor(int i = 0; i &lt; n; i++)\t&#123;\t\tcout &lt;&lt;s3[i];\t&#125;&#125;int main()&#123;\tint T = 1;\t//cin &gt;&gt; T;\twhile(T--)\t&#123;\t\tslove();\t&#125;\treturn 0;&#125;\n\n","categories":["数据结构"],"tags":["模拟"]},{"title":"C++运算符重载","url":"/2025/07/12/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","content":"C++运算符重载1.定义：\n​\t运算符重载是为自定义（类，结构体）定义运算符行为。\n2.实现方式：\n​\t**成员函数：**运算符左操作数为当前对象（this）,右操作数为参数。\n​\t**非成员函数（友元）：**适用于对称处理操作数或访问私有成员的情况。\n3.实例：\n1.加号运算符：#include&lt;iostream&gt;//加号运算符重载//注意：//对于内置的数据类型的表达式的运算符是不可能改变的//不要滥用运算符重载using namespace std;class Person&#123;public:\t//1.成员函数重载+号\t/*Person operator+(Person &amp;p)\t&#123;\t\tPerson temp;\t\ttemp.m_A = this-&gt;m_A + p.m_A;\t\ttemp.m_B = this-&gt;m_B + p.m_B;\t\treturn temp;\t&#125;*/\tint m_A;\tint m_B;&#125;; //2.全局函数重载+号Person operator+(Person&amp; p1, Person&amp; p2)&#123;\tPerson temp;\ttemp.m_A = p1.m_A + p2.m_A;\ttemp.m_B = p1.m_B + p2.m_B;\treturn temp;&#125; //函数重载的版本Person operator+(Person&amp; p1, int num)&#123;\tPerson temp;\ttemp.m_A = p1.m_A + num;\ttemp.m_B = p1.m_B + num;\treturn temp;&#125;void test01()&#123;\tPerson p1;\tp1.m_A = 10;\tp1.m_B = 10;\tPerson p2;\tp2.m_A = 10;\tp2.m_B = 10; \t//成员函数重载本质调用\t//Person p3 = p1.operator+(p2); \t全局函数的本质调用\t//Person p3 = operator+(p1, p2);\tPerson p3 = p1 + p2;  \t//运算符重载 也可以发生函数重载\tPerson p4 = p1 + 100;//Person + int \t\tcout &lt;&lt; &quot;p3.m_A = &quot; &lt;&lt; p3.m_A &lt;&lt; &quot; p3.m_B = &quot; &lt;&lt; p3.m_B &lt;&lt; endl;\tcout &lt;&lt; &quot;p4.m_A =  &quot; &lt;&lt; p4.m_A&lt;&lt; &quot; p4.m_B = &quot; &lt;&lt; p4.m_B &lt;&lt; endl;&#125;  int main()&#123;\ttest01();\treturn 0;&#125;\n\n\n\n2.左移运算符：#include&lt;iostream&gt;using namespace std; //左移运算符重载//总结：重载左移运算符配合友元可以实现输出自定义数据类型class Person&#123;\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person&amp; m);\t//1.利用成员函数重载， 左移运算符  p.operator&lt;&lt;(cout) 简化版本 p&lt;&lt;cout\t//不会用成员函数重载&lt;&lt;运算符，因为无法实现cout在左侧\t/*void operator&lt;&lt;(Person&amp; p)\t&#123;\t&#125;*/public:\tPerson(int a, int b)//构造函数：​​构造函数的作用​​：在创建对象时初始化私有成员，避免类外直接赋值的非法操作。\t&#123;\t\tm_A = a;\t\tm_B = b;\t&#125;\tPerson(): m_A(0),m_B(0) &#123;&#125;private: \tint m_A;\tint m_B;&#125;; //只能利用全局函数重载左移运算符ostream &amp;operator&lt;&lt;(ostream &amp;cout ,Person &amp;m) //本质： operator&lt;&lt;(cout,p) 简化 cout &lt;&lt;p&#123;\tcout &lt;&lt; &quot;m_A = &quot; &lt;&lt; m.m_A&lt;&lt; &quot; m_B = &quot; &lt;&lt; m.m_B;\treturn cout;&#125;void test01()&#123;\tPerson p(10,10);\t//p.m_A = 10;\t//p.m_B = 10;\tPerson s;\tcout &lt;&lt; p &lt;&lt;&quot; Hello world!&quot; &lt;&lt; endl;\tcout &lt;&lt; s &lt;&lt; endl;&#125;int main()&#123;\ttest01();\treturn 0;&#125;\n\n3.赋值运算符：#include&lt;iostream&gt;using namespace std;//赋值运算符重载class Person&#123;public:\tPerson(int age)\t&#123;\t\tm_Age = new int(age);\t&#125;\t~Person()\t&#123;\t\tif (m_Age != NULL)\t\t&#123;\t\t\tdelete m_Age;\t\t\tm_Age = NULL;\t\t&#125;\t&#125; \t//重载 赋值运算符\tPerson&amp; operator=(Person&amp; p)\t&#123;\t\t//编译器提供浅拷贝\t\t//m_Age = p.m_Age; \t\t//应该先判断是否有属性在堆区，如果有先释放干净，然后再深拷贝\t\tif (m_Age != NULL)\t\t&#123;\t\t\tdelete m_Age;\t\t\tm_Age = NULL;\t\t&#125;\t\t//深拷贝\t\tm_Age = new int(*p.m_Age); \t\treturn *this;\t&#125;\tint* m_Age;&#125;;void test01()&#123;\tPerson p1(18);\tPerson p2(20);\tPerson p3(30);\tp3 = p2 = p1;\tp2 = p1;//浅拷贝，析构释放内存会指向同一块内存，所以不行，要重载\tcout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main()&#123;\ttest01();\t/*int a = 10;\tint b = 20;\tint c = 30;\tc = b = a;\tcout &lt;&lt; &quot;a =  &quot; &lt;&lt; a &lt;&lt; &quot; b =  &quot; &lt;&lt;  b &lt;&lt; &quot; c =  &quot; &lt;&lt; c &lt;&lt; endl;*/\treturn 0;&#125;\n\n4.关系运算符：#include&lt;iostream&gt;using namespace std;//关系运算符重载class Person&#123;public:\tPerson(string name, int age)\t&#123;\t\tm_name = name;\t\tm_age = age;\t&#125;\t//重载==号\tbool operator==(Person &amp;p)\t&#123;\t\tif (this-&gt;m_name == p.m_name &amp;&amp; this-&gt;m_age == p.m_age)\t\t&#123;\t\t\treturn true;\t\t&#125;\t\treturn false;\t&#125;\tbool operator!=(Person&amp; p)\t&#123;\t\tif (this-&gt;m_name == p.m_name &amp;&amp; this-&gt;m_age == p.m_age)\t\t&#123;\t\t\treturn false;\t\t&#125;\t\treturn true;\t&#125;\tstring m_name;\tint m_age;&#125;;void test01()&#123;\tPerson p1(&quot;Tom&quot;, 18);\tPerson p2(&quot;Terry&quot;,18);\tif (p1 == p2)\t&#123;\t\tcout &lt;&lt; &quot;p1与p2是相等的&quot; &lt;&lt; endl;\t&#125;\telse &#123;\t\tcout &lt;&lt; &quot;p1与p2不相等&quot; &lt;&lt; endl;\t&#125;\tif (p1 != p2)\t&#123;\t\tcout &lt;&lt; &quot;p1与p2不是相等的&quot; &lt;&lt; endl;\t&#125;\telse &#123;\t\tcout &lt;&lt; &quot;p1与p2相等&quot; &lt;&lt; endl;\t&#125;&#125;int main()&#123;\ttest01();\treturn 0;&#125;\n\n\n\n5.递减运算符：#include&lt;iostream&gt;using namespace std;//递减运算符class MyInteger&#123;\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint);public:\tMyInteger()\t&#123;\t\tm_num = 0;\t&#125;\tMyInteger&amp; operator--()//前置\t&#123;\t\t//先剪\t\tm_num--;\t\t//后输出\t\treturn *this;\t&#125;\tMyInteger operator--(int)\t&#123;\t\t//先记录当前值\t\tMyInteger temp = *this;\t\t//进行递减\t\tm_num--;\t\t//最后输出\t\treturn temp;\t&#125;private:\tint m_num;&#125;; ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint)&#123;\tcout &lt;&lt; myint.m_num;\treturn cout;&#125;void test01()&#123;\tMyInteger myint;\tcout &lt;&lt; myint &lt;&lt; endl;\tcout &lt;&lt; --myint &lt;&lt; endl;&#125; void test02()&#123;\tMyInteger myint;\tcout &lt;&lt; myint&lt;&lt;endl;\tcout &lt;&lt; myint-- &lt;&lt; endl;\tcout &lt;&lt; myint &lt;&lt; endl;&#125;int main()&#123;\ttest01();\ttest02();\treturn 0;&#125;\n\n6.递增运算符：#include&lt;iostream&gt;using namespace std;//递增运算符重载++//作用：通过重载递增运算符，实现自己的整数类型//自定义整形class MyInteger&#123;\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint); public:\tMyInteger()\t&#123;\t\tm_Num = 0;\t&#125;\t//重载前置++运算符 返回引用是为了一直对一个数据进行递增操作\tMyInteger&amp; operator++()\t&#123;\t\t//先进行++操作\t\tm_Num++;\t\t//再将自身做返回\t\treturn *this;\t&#125;\t//重载后置++运算符 用int作为占位符，防止发生函数重载失败\tMyInteger operator++(int)\t&#123;\t\t//先 记录当时结果\t\tMyInteger temp = *this;\t\t//后自增\t\tm_Num++;\t\t//输出 返回结果\t\treturn temp;\t&#125;private:\tint m_Num;&#125;; //重载左移运算符&lt;&lt;ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint)&#123;\tcout &lt;&lt; myint.m_Num;\treturn cout;&#125;void test01()&#123;\tMyInteger myint; \tcout &lt;&lt; ++myint &lt;&lt; endl;&#125;void  test02()&#123;\tMyInteger myint;\tcout &lt;&lt; myint++&lt;&lt;endl;\tcout &lt;&lt; myint &lt;&lt; endl;&#125;int main()&#123;\ttest01();\ttest02();\treturn 0;&#125;\n\n7.函数调用运算符重载：#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;//函数运算符()也重载//由于重载后使用的方式非常像函数的调用，因此称为仿函数//仿函数没有固定写法，非常灵活  //打印输出类class MyPrint&#123;public:\t//重载函数调用运算符\tvoid operator()(string test)\t&#123;\t\tcout &lt;&lt; test;\t&#125;&#125;;void MyPrint02(string test)&#123;\tcout &lt;&lt; test;&#125;void test01()&#123;\tMyPrint myprint;\tmyprint(&quot;Hello,World!&quot;) ; //由于使用起来非常类似于函数调用，因此称为仿函数\tcout &lt;&lt; endl;\tMyPrint02(&quot;NiHao!&quot;);\tcout &lt;&lt; endl;&#125; //仿函数非常灵活，没有固定的写法//加法类class MyAdd&#123;public:\tint operator()(int num1, int num2)\t&#123;\t\treturn num1 + num2;\t&#125;\t&#125;;void test02()&#123;\tMyAdd myadd;\tint res = myadd(100, 100);\tcout &lt;&lt; &quot;res = &quot; &lt;&lt; res &lt;&lt; endl;\t//匿名函数对象 MyAdd()\tcout &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125;int main()&#123;\ttest01();\ttest02();\treturn 0;&#125;\n\n感谢观看，欢迎评论！！！","tags":["C++"]},{"title":"function的底层原理的浅理解","url":"/2025/07/30/function%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E7%9A%84%E6%B5%85%E7%90%86%E8%A7%A3/","content":"function的底层原理的浅理解📌核心原理 （一句话）​ std::function通过类型擦除技术封装任意可调用对象，提供统一的函数调用接口operator()\n🧠 核心实现要点（面试常考）1. 类型擦除（Type Erasure）template&lt;typename R, typename... A&gt;class myfunction&lt;R(A...)&gt; &#123;    using PFUNC = R(*)(A...); // 关键类型定义    PFUNC _pfunc; // 存储函数指针&#125;;\n\n\n实现目标：抹去不同类型函数的差异\n技术手段：\n使用函数指针类型统一接口\n通过模板特化处理不同函数签名\n\n\n\n2.可变参数模板（Variadic Templates）R operator() (A... arg) &#123;    return _pfunc(arg...); // 参数包解包&#125;\n\n\n... 表示参数包\n解决不同参数数量的通用处理\n支持0到任意数量参数\n\n3. 统一调用接口// 调用方式统一为 operator()myfunction&lt;void(string)&gt; func = hello;func(&quot;world&quot;); // 像函数一样调用\n\n实现核心代码// 主模板声明（空实现）template&lt;typename Fty&gt; class myfunction;// 特化版本（处理任意返回值+任意参数）template&lt;typename R, typename... A&gt;class myfunction&lt;R(A...)&gt; &#123;public:    using PFUNC = R(*)(A...); // 函数指针类型        myfunction(PFUNC pfunc) : _pfunc(pfunc) &#123;&#125; // 存储函数指针        // 统一调用接口    R operator()(A... arg) &#123;        return _pfunc(arg...); // 解包参数    &#125;private:    PFUNC _pfunc; // 存储的函数指针&#125;;\n\n使用示例（测试用例）// 测试函数1：string参数void hello(string str) &#123;    cout &lt;&lt; str &lt;&lt; endl;&#125;// 测试函数2：多参数int sum(int a, int b) &#123;    return a + b;&#125;int main() &#123;    // 1. 封装void(string)函数    myfunction&lt;void(string)&gt; func1 = hello;    func1(&quot;hello&quot;); // 调用输出：hello        // 2. 封装int(int,int)函数    myfunction&lt;int(int, int)&gt; func2 = sum;    cout &lt;&lt; func2(20, 30); // 输出：50        return 0;&#125;\n\n完整示例代码#include&lt;iostream&gt;#include&lt;typeinfo&gt;#include&lt;string&gt;#include&lt;functional&gt;using namespace std;/*function 函数对象类型的实现原理*/void hello(string str)&#123;\tcout &lt;&lt; str &lt;&lt; endl;&#125;int sum(int a, int b)&#123;\treturn a + b;&#125;/// ///////////////////////////////////////////template&lt;typename Fty&gt;class myfunction&#123; &#125;;//template&lt;typename R, typename A1&gt;//class myfunction&lt;R(A1)&gt;//&#123;//public://\tusing PFUNC = R(*) (A1);//\tmyfunction(PFUNC pfunc) :_pfunc(pfunc) &#123; &#125;//\tR operator() (A1 arg)//\t&#123;//\t\treturn _pfunc(arg);//\t&#125;//private://\tPFUNC _pfunc;//&#125;;////template&lt;typename R, typename A1,typename A2&gt;//class myfunction&lt;R(A1,A2)&gt;//&#123;//public://\tusing PFUNC = R(*) (A1,A2);//\tmyfunction(PFUNC pfunc) :_pfunc(pfunc) &#123;&#125;//\tR operator() (A1 arg1,A2 arg2)//\t&#123;//\t\treturn _pfunc(arg1,arg2);//\t&#125;//private://\tPFUNC _pfunc;//&#125;;template&lt;typename R, typename... A&gt; //...代表可变参class myfunction&lt;R(A...)&gt;&#123;public:\tusing PFUNC = R(*) (A...);\tmyfunction(PFUNC pfunc) :_pfunc(pfunc) &#123;&#125;\tR operator() (A... arg)\t&#123;\t\treturn _pfunc(arg...);\t&#125;private:\tPFUNC _pfunc;&#125;;int main()&#123;\tmyfunction&lt;void(string)&gt; func1 = hello;\tfunc1(&quot;hello hello 1!&quot;);\tmyfunction&lt;int(int, int)&gt; func2(sum);\tcout &lt;&lt; func2(20, 30) &lt;&lt;endl;\treturn 0;&#125;\n\n结束！！！","tags":["C++"]},{"title":"转换UML图的演示","url":"/2025/07/07/test/","content":"\n    graph TD\n    A[开始] --&gt; B(处理中)\n    B --&gt; C{判断}\n    C --&gt;|是| D[完成]\n    C --&gt;|否| B\n  ","categories":["技术教程"]},{"title":"代码演示","url":"/2025/07/07/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/","content":"int main()&#123;    cout &lt;&lt; &quot;hello world!&quot;&lt;&lt;endl;    return 0;&#125;","tags":["C++"]},{"title":"左值与右值及其应用","url":"/2025/07/14/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/","content":"左值与右值及其应用一、左值与右值的概念1. 定义\n左值：可放置在赋值运算符左侧的值，具有持久存储位置的对象\n右值：不具有固定存储位置的临时值，表达式求值后立即销毁\nC++标准定义：表达式求值后具有身份（identity）和存储位置的是glvalue（泛左值），可以被移动的是rvalue（右值）\n\n2. 左值特点\n持久性：生命周期超出当前表达式\n可寻址：可用&amp;获取内存地址\n可赋值：可放在赋值表达式左侧\n具名性：通常有标识符名称\n\nint a = 10;     // a是左值int* ptr = &amp;a;  // a可寻址a = 20;         // a可赋值\n\n3. 右值特点\n临时性：在表达式结束即销毁\n不可寻址：无法获取内存地址\n不可赋值：不能放在赋值表达式左侧\n匿名性：通常没有标识符名称\n\n42;               // 字面量（纯右值）func();           // 返回临时对象（纯右值）std::move(a);     // 将亡值（Xvalue）\n\n4. 值类别划分\n    graph TD\n    A[表达式] \n    A --&gt; B[泛左值 glvalue]\n    A --&gt; C[右值 rvalue]\n    B --&gt; D[左值 lvalue]\n    B --&gt; E[将亡值 xvalue]\n    C --&gt; E[将亡值 xvalue]\n    C --&gt; F[纯右值 prvalue]\n  \n\n\n\n\n类别\n名称\n特征\n示例\n\n\n\nlvalue\n左值\n有标识&amp;持久\n具名变量int x = 5;\n\n\nxvalue\n将亡值\n有标识但可被移动\nstd::move(x)\n\n\nprvalue\n纯右值\n无标识&amp;临时\n42, func()\n\n\nglvalue\n泛左值\n有标识\nlvalue + xvalue\n\n\nrvalue\n右值\n可被移动\nxvalue + prvalue\n\n\n二、左值引用与右值引用1. 引用类型对比\n\n\n特性\n左值引用 (T&amp;)\n常量左值引用 (const T&amp;)\n右值引用 (T&amp;&amp;)\n\n\n\n符号\n&amp;\nconst &amp;\n&amp;&amp;\n\n\n可绑定左值\n✅\n✅\n❌\n\n\n可绑定右值\n❌\n✅\n✅\n\n\n可修改对象\n✅\n❌\n✅\n\n\n主要用途\n避免拷贝\n通用访问\n资源转移\n\n\n2. 左值引用 (T&amp;)基本概念：只能绑定到左值的引用，提供对现有对象的别名访问\nint a = 10; int&amp; ref = a;   // ✅ 正确绑定左值ref = 20;       // 通过引用修改原对象int&amp; err = 42;  // ❌ 错误：不能绑定右值\n\n实现原理：在编译层面维护指针语义，运行时零开销\n3. 右值引用 (T&amp;&amp;)基本概念：只能绑定到右值的引用，用于移动语义\nstd::vector&lt;int&gt; createVector();std::vector&lt;int&gt;&amp;&amp; rref = createVector(); // ✅ 绑定临时对象int x = 10;int&amp;&amp; err = x;  // ❌ 错误：不能直接绑定左值int&amp;&amp; valid = std::move(x); // ✅ 通过std::move转为右值\n\n关键特征：\n\n延长临时对象的生命周期\n支持移动语义避免深拷贝\n实现完美转发\n\n4. 常量左值引用 (const T&amp;)特殊属性：可同时绑定左值和右值的只读引用\nconst int&amp; cref1 = 10;    // ✅ 绑定右值int x = 20;const int&amp; cref2 = x;     // ✅ 绑定左值// cref2 = 30;           // ❌ 不可修改\n\n优化价值：避免不必要的对象拷贝\n注意： 一个右值引用变量，本身是一个左值！！！！！！！\n三、应用场景解析1. 左值引用应用场景(1) 函数传参（避免拷贝）// 高效：引用传递（零拷贝）void processVector(vector&lt;int&gt;&amp; v) &#123;    // 操作大型容器&#125;vector&lt;int&gt; bigData(1e6);processVector(bigData);  // 避免复制百万元素\n\n(2) 拷贝语义实现class Matrix &#123;public:    // 拷贝构造函数    Matrix(const Matrix&amp; other) &#123;        copyData(other.data); // 深拷贝实现    &#125;        // 拷贝赋值运算符    Matrix&amp; operator=(const Matrix&amp; other) &#123;        if (this != &amp;other) &#123;            freeData();            copyData(other.data);        &#125;        return *this;    &#125;&#125;;\n\n(3) 多返回值机制// 通过引用参数返回多个计算结果void computeStats(const Dataset&amp; data,                  double&amp; mean,                  double&amp; variance) &#123;    // 计算统计值&#125;// 调用double avg, var;computeStats(largeData, avg, var);\n\n2. 右值引用应用场景(1) 移动语义优化class MemoryBlock &#123;public:    // 移动构造函数    MemoryBlock(MemoryBlock&amp;&amp; other) noexcept         : data(other.data), size(other.size) &#123;        other.data = nullptr; // 资源转移    &#125;    private:    char* data;    size_t size;&#125;;MemoryBlock createBlock();MemoryBlock mb = createBlock(); // 触发移动构造\n\n(2) 完美转发机制template&lt;typename T&gt;void relay(T&amp;&amp; arg) &#123;    // 保持值类别完美转发    process(std::forward&lt;T&gt;(arg));&#125;relay(42);            // 转发右值int x = 10;relay(x);             // 转发左值\n\n(3) 高效算法实现// 使用移动语义高效交换对象template&lt;typename T&gt;void swap(T&amp; a, T&amp; b) noexcept &#123;    T temp(std::move(a));    a = std::move(b);    b = std::move(temp);&#125;\n\n四、综合应用实例1. 工厂模式优化template&lt;typename T, typename... Args&gt;T create(Args&amp;&amp;... args) &#123;    // 完美转发构造参数    return T(std::forward&lt;Args&gt;(args)...);&#125;auto vec = create&lt;vector&lt;int&gt;&gt;(1000, 42); // 原地构造\n\n2. RAII资源管理class FileHandle &#123;public:    FileHandle(string_view path) : handle(openFile(path)) &#123;&#125;        // 移动支持    FileHandle(FileHandle&amp;&amp; other) noexcept         : handle(other.handle) &#123;        other.handle = nullptr;    &#125;        ~FileHandle() &#123; if(handle) closeFile(handle); &#125;private:    FILE* handle;&#125;;\n\n3. 容器优化策略vector&lt;Matrix&gt; largeMatrices;// 添加元素时的优化largeMatrices.push_back(Matrix(1000, 1000));  // C++11前：拷贝                                              // C++11后：移动\n\n五、最佳实践建议\n优先使用const T&amp;：作为函数参数时，除非需要修改\n\n为资源管理类实现移动语义：显著提升资源转移效率\n\n理解std::move本质：static_cast&lt;T&amp;&amp;&gt;，不移动任何数据\n\n警惕万能引用陷阱：T&amp;&amp;在模板推导中成为万能引用\n\n值类别判断技巧：\nauto valueCategory = [](auto&amp;&amp; x) &#123;     return std::is_rvalue_reference_v&lt;decltype(x)&gt; ?          &quot;Rvalue&quot; : &quot;Lvalue&quot;;&#125;;\n\n六、现代C++演进\nC++11：引入右值引用和移动语义\nC++14：优化通用引用规则\nC++17：强复制消除保证\nC++20：新增移动语义应用场景\nC++23：移动语义扩展至其他语言特性\n\n","tags":["C++"]}]