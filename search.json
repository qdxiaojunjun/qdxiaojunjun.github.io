[{"title":"转换UML图的演示","url":"/2025/07/07/test/","content":"\n    graph TD\n    A[开始] --&gt; B(处理中)\n    B --&gt; C{判断}\n    C --&gt;|是| D[完成]\n    C --&gt;|否| B\n  ","categories":["技术教程"]},{"title":"代码演示","url":"/2025/07/07/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/","content":"int main()&#123;    cout &lt;&lt; &quot;hello world!&quot;&lt;&lt;endl;    return 0;&#125;","tags":["C++"]},{"title":"C++运算符重载","url":"/2025/07/12/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","content":"C++运算符重载1.定义：\n​\t运算符重载是为自定义（类，结构体）定义运算符行为。\n2.实现方式：\n​\t**成员函数：**运算符左操作数为当前对象（this）,右操作数为参数。\n​\t**非成员函数（友元）：**适用于对称处理操作数或访问私有成员的情况。\n3.实例：\n1.加号运算符：#include&lt;iostream&gt;//加号运算符重载//注意：//对于内置的数据类型的表达式的运算符是不可能改变的//不要滥用运算符重载using namespace std;class Person&#123;public:\t//1.成员函数重载+号\t/*Person operator+(Person &amp;p)\t&#123;\t\tPerson temp;\t\ttemp.m_A = this-&gt;m_A + p.m_A;\t\ttemp.m_B = this-&gt;m_B + p.m_B;\t\treturn temp;\t&#125;*/\tint m_A;\tint m_B;&#125;; //2.全局函数重载+号Person operator+(Person&amp; p1, Person&amp; p2)&#123;\tPerson temp;\ttemp.m_A = p1.m_A + p2.m_A;\ttemp.m_B = p1.m_B + p2.m_B;\treturn temp;&#125; //函数重载的版本Person operator+(Person&amp; p1, int num)&#123;\tPerson temp;\ttemp.m_A = p1.m_A + num;\ttemp.m_B = p1.m_B + num;\treturn temp;&#125;void test01()&#123;\tPerson p1;\tp1.m_A = 10;\tp1.m_B = 10;\tPerson p2;\tp2.m_A = 10;\tp2.m_B = 10; \t//成员函数重载本质调用\t//Person p3 = p1.operator+(p2); \t全局函数的本质调用\t//Person p3 = operator+(p1, p2);\tPerson p3 = p1 + p2;  \t//运算符重载 也可以发生函数重载\tPerson p4 = p1 + 100;//Person + int \t\tcout &lt;&lt; &quot;p3.m_A = &quot; &lt;&lt; p3.m_A &lt;&lt; &quot; p3.m_B = &quot; &lt;&lt; p3.m_B &lt;&lt; endl;\tcout &lt;&lt; &quot;p4.m_A =  &quot; &lt;&lt; p4.m_A&lt;&lt; &quot; p4.m_B = &quot; &lt;&lt; p4.m_B &lt;&lt; endl;&#125;  int main()&#123;\ttest01();\treturn 0;&#125;\n\n\n\n2.左移运算符：#include&lt;iostream&gt;using namespace std; //左移运算符重载//总结：重载左移运算符配合友元可以实现输出自定义数据类型class Person&#123;\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person&amp; m);\t//1.利用成员函数重载， 左移运算符  p.operator&lt;&lt;(cout) 简化版本 p&lt;&lt;cout\t//不会用成员函数重载&lt;&lt;运算符，因为无法实现cout在左侧\t/*void operator&lt;&lt;(Person&amp; p)\t&#123;\t&#125;*/public:\tPerson(int a, int b)//构造函数：​​构造函数的作用​​：在创建对象时初始化私有成员，避免类外直接赋值的非法操作。\t&#123;\t\tm_A = a;\t\tm_B = b;\t&#125;\tPerson(): m_A(0),m_B(0) &#123;&#125;private: \tint m_A;\tint m_B;&#125;; //只能利用全局函数重载左移运算符ostream &amp;operator&lt;&lt;(ostream &amp;cout ,Person &amp;m) //本质： operator&lt;&lt;(cout,p) 简化 cout &lt;&lt;p&#123;\tcout &lt;&lt; &quot;m_A = &quot; &lt;&lt; m.m_A&lt;&lt; &quot; m_B = &quot; &lt;&lt; m.m_B;\treturn cout;&#125;void test01()&#123;\tPerson p(10,10);\t//p.m_A = 10;\t//p.m_B = 10;\tPerson s;\tcout &lt;&lt; p &lt;&lt;&quot; Hello world!&quot; &lt;&lt; endl;\tcout &lt;&lt; s &lt;&lt; endl;&#125;int main()&#123;\ttest01();\treturn 0;&#125;\n\n3.赋值运算符：#include&lt;iostream&gt;using namespace std;//赋值运算符重载class Person&#123;public:\tPerson(int age)\t&#123;\t\tm_Age = new int(age);\t&#125;\t~Person()\t&#123;\t\tif (m_Age != NULL)\t\t&#123;\t\t\tdelete m_Age;\t\t\tm_Age = NULL;\t\t&#125;\t&#125; \t//重载 赋值运算符\tPerson&amp; operator=(Person&amp; p)\t&#123;\t\t//编译器提供浅拷贝\t\t//m_Age = p.m_Age; \t\t//应该先判断是否有属性在堆区，如果有先释放干净，然后再深拷贝\t\tif (m_Age != NULL)\t\t&#123;\t\t\tdelete m_Age;\t\t\tm_Age = NULL;\t\t&#125;\t\t//深拷贝\t\tm_Age = new int(*p.m_Age); \t\treturn *this;\t&#125;\tint* m_Age;&#125;;void test01()&#123;\tPerson p1(18);\tPerson p2(20);\tPerson p3(30);\tp3 = p2 = p1;\tp2 = p1;//浅拷贝，析构释放内存会指向同一块内存，所以不行，要重载\tcout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main()&#123;\ttest01();\t/*int a = 10;\tint b = 20;\tint c = 30;\tc = b = a;\tcout &lt;&lt; &quot;a =  &quot; &lt;&lt; a &lt;&lt; &quot; b =  &quot; &lt;&lt;  b &lt;&lt; &quot; c =  &quot; &lt;&lt; c &lt;&lt; endl;*/\treturn 0;&#125;\n\n4.关系运算符：#include&lt;iostream&gt;using namespace std;//关系运算符重载class Person&#123;public:\tPerson(string name, int age)\t&#123;\t\tm_name = name;\t\tm_age = age;\t&#125;\t//重载==号\tbool operator==(Person &amp;p)\t&#123;\t\tif (this-&gt;m_name == p.m_name &amp;&amp; this-&gt;m_age == p.m_age)\t\t&#123;\t\t\treturn true;\t\t&#125;\t\treturn false;\t&#125;\tbool operator!=(Person&amp; p)\t&#123;\t\tif (this-&gt;m_name == p.m_name &amp;&amp; this-&gt;m_age == p.m_age)\t\t&#123;\t\t\treturn false;\t\t&#125;\t\treturn true;\t&#125;\tstring m_name;\tint m_age;&#125;;void test01()&#123;\tPerson p1(&quot;Tom&quot;, 18);\tPerson p2(&quot;Terry&quot;,18);\tif (p1 == p2)\t&#123;\t\tcout &lt;&lt; &quot;p1与p2是相等的&quot; &lt;&lt; endl;\t&#125;\telse &#123;\t\tcout &lt;&lt; &quot;p1与p2不相等&quot; &lt;&lt; endl;\t&#125;\tif (p1 != p2)\t&#123;\t\tcout &lt;&lt; &quot;p1与p2不是相等的&quot; &lt;&lt; endl;\t&#125;\telse &#123;\t\tcout &lt;&lt; &quot;p1与p2相等&quot; &lt;&lt; endl;\t&#125;&#125;int main()&#123;\ttest01();\treturn 0;&#125;\n\n\n\n5.递减运算符：#include&lt;iostream&gt;using namespace std;//递减运算符class MyInteger&#123;\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint);public:\tMyInteger()\t&#123;\t\tm_num = 0;\t&#125;\tMyInteger&amp; operator--()//前置\t&#123;\t\t//先剪\t\tm_num--;\t\t//后输出\t\treturn *this;\t&#125;\tMyInteger operator--(int)\t&#123;\t\t//先记录当前值\t\tMyInteger temp = *this;\t\t//进行递减\t\tm_num--;\t\t//最后输出\t\treturn temp;\t&#125;private:\tint m_num;&#125;; ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint)&#123;\tcout &lt;&lt; myint.m_num;\treturn cout;&#125;void test01()&#123;\tMyInteger myint;\tcout &lt;&lt; myint &lt;&lt; endl;\tcout &lt;&lt; --myint &lt;&lt; endl;&#125; void test02()&#123;\tMyInteger myint;\tcout &lt;&lt; myint&lt;&lt;endl;\tcout &lt;&lt; myint-- &lt;&lt; endl;\tcout &lt;&lt; myint &lt;&lt; endl;&#125;int main()&#123;\ttest01();\ttest02();\treturn 0;&#125;\n\n6.递增运算符：#include&lt;iostream&gt;using namespace std;//递增运算符重载++//作用：通过重载递增运算符，实现自己的整数类型//自定义整形class MyInteger&#123;\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint); public:\tMyInteger()\t&#123;\t\tm_Num = 0;\t&#125;\t//重载前置++运算符 返回引用是为了一直对一个数据进行递增操作\tMyInteger&amp; operator++()\t&#123;\t\t//先进行++操作\t\tm_Num++;\t\t//再将自身做返回\t\treturn *this;\t&#125;\t//重载后置++运算符 用int作为占位符，防止发生函数重载失败\tMyInteger operator++(int)\t&#123;\t\t//先 记录当时结果\t\tMyInteger temp = *this;\t\t//后自增\t\tm_Num++;\t\t//输出 返回结果\t\treturn temp;\t&#125;private:\tint m_Num;&#125;; //重载左移运算符&lt;&lt;ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint)&#123;\tcout &lt;&lt; myint.m_Num;\treturn cout;&#125;void test01()&#123;\tMyInteger myint; \tcout &lt;&lt; ++myint &lt;&lt; endl;&#125;void  test02()&#123;\tMyInteger myint;\tcout &lt;&lt; myint++&lt;&lt;endl;\tcout &lt;&lt; myint &lt;&lt; endl;&#125;int main()&#123;\ttest01();\ttest02();\treturn 0;&#125;\n\n7.函数调用运算符重载：#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;//函数运算符()也重载//由于重载后使用的方式非常像函数的调用，因此称为仿函数//仿函数没有固定写法，非常灵活  //打印输出类class MyPrint&#123;public:\t//重载函数调用运算符\tvoid operator()(string test)\t&#123;\t\tcout &lt;&lt; test;\t&#125;&#125;;void MyPrint02(string test)&#123;\tcout &lt;&lt; test;&#125;void test01()&#123;\tMyPrint myprint;\tmyprint(&quot;Hello,World!&quot;) ; //由于使用起来非常类似于函数调用，因此称为仿函数\tcout &lt;&lt; endl;\tMyPrint02(&quot;NiHao!&quot;);\tcout &lt;&lt; endl;&#125; //仿函数非常灵活，没有固定的写法//加法类class MyAdd&#123;public:\tint operator()(int num1, int num2)\t&#123;\t\treturn num1 + num2;\t&#125;\t&#125;;void test02()&#123;\tMyAdd myadd;\tint res = myadd(100, 100);\tcout &lt;&lt; &quot;res = &quot; &lt;&lt; res &lt;&lt; endl;\t//匿名函数对象 MyAdd()\tcout &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125;int main()&#123;\ttest01();\ttest02();\treturn 0;&#125;\n\n感谢观看，欢迎评论！！！","tags":["C++"]}]